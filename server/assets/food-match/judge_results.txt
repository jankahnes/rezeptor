So we have this food item query:

{query}

We have searched our database for foods that might be relevant to this food item. While we have not found exact matches, we have found these entries:

{results}

Your job is to judge what to do with the query. Simply, either the query will be added as an alias to an existing food in the database (with a reference to that foods nutrition and metadata) (Case 1),
or the query will be used to generate a new base food (Case 2).

When to judge as alias / Case 1:
- There exists one or multiple foods in the search results that refer to the same or a very similar food.
- Also, you expect that matching food to have:
    - The same or only minimally different nutritional data, also including amino acids and micronutrients
    - We included the kcal/100g for each entry, that can sometimes aid you in judging if the foods would match or not.
    - The same or only minimally different metadata, such as processing level, density, price, and ways to measure
    - Keep in mind that unless specified otherwise, the foods in the database refer to the raw/unprocessed versions of the foods.
- In that case, mark the ID of that food (if multiple match, just do the best one) in your response as matching_id
- According to the rules above, low-sodium/low-fat/high-protein etc. versions of foods are *not* aliases,
as the whole point of using them is that they differ substantially in at least one nutritional aspect. 
-Another hard case: is "Marrow Bone" an alias to "Bone Marrow"? No, since the Marrow Bone is the whole bone, and has per 100g only a small edible portion of Bone Marrow.
So per 100g, something like kcal would be different.

When not to judge as alias / Case 2:
- There does not exist a food that fulfills Case 1 in the search results

Other / Case 3:
- If there is something wrong with the query (Not a food, bad word, etc.), return "reject". 

In both cases, check if the given query fulfills the format requirements for the database and reformat accordingly.
- Title case / Headline case
- Simple, intuitive. Not overly descriptive. No explanations or examples, just a short name/title.
- "Canned Tomatoes", "Tomatoes, canned", "Tomatoes (Canned)" are all allowed, but prefer variants in that order if possible and natural.
- If added as alias to X, should not include a 1:1 reference to X in the title.
    -> "Ribeye Steak" as reference to "Ribeye" is allowed. However, if you want to point something like 
    "Pimentón Dulce (Spanish sweet paprika spice)" to "Sweet paprika powder", you should reformat the query to "Pimentón Dulce".
- The query should describe a singular food item, not a mixture of two that could be seperate entries, unless the mixture sold as one or used in recipes as one.
- The query should especially not include an "or" or provide alternatives to other foods.
- Of course, when reformatting, you cannot reformat the name to be EXACTLY any of the above results - the whole point is to add an alias for the query to match in the future.

The query is likely to fulfill these requirements already, in which case you can just copy the query to the field.

Lastly, an edge case. If you land on Case 2, but dont think the query is suitable as primary food name in an english database (-> you can think of a better primary name), add that name to your response.
In the above example, lets say the query is "Pimentón Dulce" and the results only include foods like "Paprika Powder", "Smoked Paprika", "Paprika (Spice)", etc. but not the exact "Sweet Paprika Powder" (matching to existing would be inaccurate / lose information)
. Add "Sweet Paprika Powder" as primary_name. The food will then be added under that primary name, and an alias pointing to it from the original query.

Your Response should now be formatted like this:
Response:
{
    "query_formatted": String,
    "judgement": "add_as_alias" | "add_as_new" | "reject",
    "matching_id": Int | null,
    "primary_name": String | null
}
