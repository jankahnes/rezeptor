So we have this food item query:

{query}

We have searched our database for foods that might be relevant to this food item. While we have not found exact matches, we have found these entries:

{results}

Your job is to judge what to do with the query. Simply, either the query will be added as an alias to an existing food in the database (with a reference to that foods nutrition and metadata) (Case 1),
or the query will be used to generate a new base food (Case 2).

Your Response should be formatted like this:
{
    "judgement": "add_as_alias" | "add_as_new" | "reject",
    "matching_id": Int | null,
    "query_name": String,
    "primary_name": String | null,
    "other_names": String[] | null
}

When to judge as alias / Case 1:
- There exists one or multiple foods in the search results that refer to the same or a very similar food.
- Also, you expect that matching food to have:
    - The same or only minimally different nutritional data, also including amino acids and micronutrients
    - We included the kcal/100g for each entry, that can sometimes aid you in judging if the foods would match or not.
    - The same or only minimally different metadata, such as processing level, density, price, and ways to measure
    - Keep in mind that unless specified otherwise, the foods in the database refer to the raw/unprocessed versions of the foods.
- In that case, mark the ID of that food (if multiple match, just do the best one) in your response as matching_id
- According to the rules above, low-sodium/low-fat/high-protein etc. versions of foods are *not* aliases,
as the whole point of using them is that they differ substantially in at least one nutritional aspect. 
-Another hard case: is "Marrow Bone" an alias to "Bone Marrow"? No, since the Marrow Bone is the whole bone, and has per 100g only a small edible portion of Bone Marrow.
So per 100g, something like kcal would be different.

When not to judge as alias / Case 2:
- There does not exist a food that fulfills Case 1 in the search results

Other / Case 3:
- If there is something wrong with the query (Not a food, bad word, etc.), return "reject". 

In both cases, check if the given query fulfills the format requirements for the database and reformat accordingly.
- Title case / Headline case
- Simple, intuitive. Not overly descriptive. No explanations or examples, just a short name/title.
- "Canned Tomatoes", "Tomatoes, canned", "Tomatoes (Canned)" are all allowed, but prefer variants in that order if possible and natural.
- Of course, when reformatting, you cannot reformat the name to be EXACTLY any of the above results - the whole point is to add an alias for the query to match in the future.
-> The formatted query goes into query_name.
If the query fulfills these requirements already, you can just copy the query.

Now, for the alternative names.
1. primary_name
This is only relevant if you add_as_new, and you feel like there is a better primary name for the new food. You should prefer clean, english names for this.
2. other_names
This is mainly relevant if the query_name is made up of two names meaning the same thing (Like a translation). In that case, put both names in other_names.

According to the above, a name can appear in multiple of the name fields, and your responses are handled accordingly.
Examples for clarity: 

Query: Vietnamese mustard greens (Cải Bẹ Xanh)
You find in results: Mustard Greens, ID: 41
With add_as_alias judgement, the name fields should be:
query_name: Vietnamese Mustard Greens (Cải Bẹ Xanh)
primary_name: null
other_names: "Vietnamese Mustard Greens", "Cải Bẹ Xanh"

Query: Pimenton Dulce
You find no Pimenton Dulce or sweet paprika powder in the results.
query_name: Pimentón Dulce
primary_name: Sweet Paprika Powder

This matters for how your prompt is processed:
- add_as_alias: query_name AND all other_names are added as aliases to matching_id
- add_as_new: 
  - Food created with (query_name ?? primary_name) in the main foods table. This name is therefore critical for further analysis for nutition and other metadata.
  - All other names (including query_name if primary_name) are then inserted as aliases into a seperate table, referencing the main food

Note that for the names you specify across the three fields, you should not specify minimally different names to query_name.
The alternative names system is for meaningfully different names.
Examples of food names that are not different enough include different spelling, capitalization, and plural/singular.